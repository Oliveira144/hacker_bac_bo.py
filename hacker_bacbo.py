import streamlit as st
import pandas as pd
import collections
import time

# --- Constantes e FunÃ§Ãµes Auxiliares ---
NUM_RECENT_RESULTS_FOR_ANALYSIS = 27
MAX_HISTORY_TO_STORE = 1000

# Resultados do Bac Bo: 'player', 'banker', 'tie'
# Mapeamento de cores para visualizaÃ§Ã£o conforme sua solicitaÃ§Ã£o
def get_color(result):
    if result == 'player': return 'blue'    # Jogador (azul)
    elif result == 'banker': return 'red'   # Banca (vermelho)
    else: return 'yellow' # Empate (amarelo)

def get_color_emoji(color):
    if color == 'blue': return 'ðŸ”µ'  # Emoji para Jogador (azul)
    elif color == 'red': return 'ðŸ”´'    # Emoji para Banca (vermelho)
    elif color == 'yellow': return 'ðŸŸ¡' # Emoji para Empate (amarelo)
    return ''

# --- FunÃ§Ãµes de AnÃ¡lise Adaptadas para Bac Bo (Jogador/Banca) ---

def analyze_surf(results):
    relevant_results = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]
    if not relevant_results:
        return {'player_sequence': 0, 'banker_sequence': 0, 'tie_sequence': 0,
                'max_player_sequence': 0, 'max_banker_sequence': 0, 'max_tie_sequence': 0}
    
    max_player_sequence = 0
    max_banker_sequence = 0
    max_tie_sequence = 0
    temp_player_seq = 0
    temp_banker_seq = 0
    temp_tie_seq = 0

    for i in range(len(relevant_results)):
        result = relevant_results[i]
        if result == 'player':
            temp_player_seq += 1; temp_banker_seq = 0; temp_tie_seq = 0
        elif result == 'banker':
            temp_banker_seq += 1; temp_player_seq = 0; temp_tie_seq = 0
        else: # tie
            temp_tie_seq += 1; temp_player_seq = 0; temp_banker_seq = 0
        max_player_sequence = max(max_player_sequence, temp_player_seq)
        max_banker_sequence = max(max_banker_sequence, temp_banker_seq)
        max_tie_sequence = max(max_tie_sequence, temp_tie_seq)

    actual_current_player_sequence = 0
    actual_current_banker_sequence = 0
    actual_current_tie_sequence = 0
    if relevant_results:
        first_result = relevant_results[0]
        for r in relevant_results:
            if r == first_result:
                if first_result == 'player': actual_current_player_sequence += 1
                elif first_result == 'banker': actual_current_banker_sequence += 1
                else: actual_current_tie_sequence += 1
            else: break
    return {
        'player_sequence': actual_current_player_sequence, 'banker_sequence': actual_current_banker_sequence,
        'tie_sequence': actual_current_tie_sequence, 'max_player_sequence': max_player_sequence,
        'max_banker_sequence': max_banker_sequence, 'max_tie_sequence': max_tie_sequence
    }

def analyze_colors(results):
    relevant_results = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]
    if not relevant_results:
        return {'blue': 0, 'red': 0, 'yellow': 0, 'current_color': '', 'streak': 0, 'color_pattern_27': ''}
    color_counts = {'blue': 0, 'red': 0, 'yellow': 0}
    for result in relevant_results:
        color = get_color(result)
        color_counts[color] += 1
    current_color = get_color(results[0]) if results else '' # Handle empty results
    streak = 0
    for result in results:  
        if get_color(result) == current_color: streak += 1
        else: break
    color_pattern_27 = ''.join([get_color(r)[0].upper() for r in relevant_results]) # B for blue, R for red, Y for yellow
    return {
        'blue': color_counts['blue'], 'red': color_counts['red'], 'yellow': color_counts['yellow'],
        'current_color': current_color, 'streak': streak, 'color_pattern_27': color_pattern_27
    }

def find_break_patterns(results):
    patterns = collections.defaultdict(int)
    relevant_results = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]
    for i in range(len(relevant_results) - 1):
        color1 = get_color(relevant_results[i])
        color2 = get_color(relevant_results[i+1])
        if color1 != color2: patterns["Quebra Simples"] += 1
        if i < len(relevant_results) - 2:
            color3 = get_color(relevant_results[i+2])
            if color1 == color2 and color1 != color3: patterns[f"2x1 ({color1.capitalize()} {get_color_emoji(color1)} {color3.capitalize()}{get_color_emoji(color3)})"] += 1
        if i < len(relevant_results) - 3:
            color3 = get_color(relevant_results[i+2])
            color4 = get_color(relevant_results[i+3])
            if color1 == color2 and color2 == color3 and color1 != color4: patterns[f"3x1 ({color1.capitalize()} {get_color_emoji(color1)} {color4.capitalize()}{get_color_emoji(color4)})"] += 1
        if i < len(relevant_results) - 3:
            color3 = get_color(relevant_results[i+2])
            color4 = get_color(relevant_results[i+3])
            if color1 == color2 and color3 == color4 and color1 != color3: patterns[f"2x2 ({color1.capitalize()} {get_color_emoji(color1)} {color3.capitalize()}{get_color_emoji(color3)})"] += 1
            if color1 != color2 and color2 != color3 and color3 != color4 and color1 == color3 and color2 == color4: patterns[f"PadrÃ£o Alternado ({color1.capitalize()}{get_color_emoji(color1)}-{color2.capitalize()}{get_color_emoji(color2)}-...)"] += 1
        if i < len(relevant_results) - 5:
            color3 = get_color(relevant_results[i+2]); color4 = get_color(relevant_results[i+3])
            color5 = get_color(relevant_results[i+4]); color6 = get_color(relevant_results[i+5])
            if color1 == color2 and color2 == color3 and color4 == color5 and color5 == color6 and color1 != color4: patterns[f"3x3 ({color1.capitalize()} {get_color_emoji(color1)} {color4.capitalize()}{get_color_emoji(color4)})"] += 1
    for i in range(len(relevant_results) - 1):
        color1 = get_color(relevant_results[i]); color2 = get_color(relevant_results[i+1])
        if color2 == 'yellow' and color1 != 'yellow': patterns[f"X Y Empate ({color1.capitalize()}{get_color_emoji(color1)} {color2.capitalize()}{get_color_emoji(color2)})"] += 1 # AdaptaÃ§Ã£o: X Y Tie -> X Y Empate
        if i < len(relevant_results) - 2:
            color3 = get_color(relevant_results[i+2])
            if color1 == 'yellow' and color2 != 'yellow' and color3 != 'yellow' and color2 != color3: patterns[f"Empate X Y ({color1.capitalize()}{get_color_emoji(color1)} {color2.capitalize()}{get_color_emoji(color2)} {color3.capitalize()}{get_color_emoji(color3)})"] += 1 # AdaptaÃ§Ã£o: Tie X Y -> Empate X Y
    return dict(patterns)

def analyze_break_probability(results):
    relevant_results = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]
    if not relevant_results or len(relevant_results) < 2: return {'break_chance': 0, 'last_break_type': ''}
    breaks = 0; total_sequences_considered = 0
    for i in range(len(relevant_results) - 1):
        if get_color(relevant_results[i]) != get_color(relevant_results[i+1]): breaks += 1
        total_sequences_considered += 1
    break_chance = (breaks / total_sequences_considered) * 100 if total_sequences_considered > 0 else 0
    last_break_type = ""
    if len(results) >= 2 and get_color(results[0]) != get_color(results[1]):
        last_break_type = f"Quebrou de {get_color(results[1]).capitalize()} {get_color_emoji(get_color(results[1]))} para {get_color(results[0]).capitalize()} {get_color_emoji(get_color(results[0]))}"
    return {'break_chance': round(break_chance, 2), 'last_break_type': last_break_type}

def analyze_tie_specifics(results):
    relevant_results = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]
    if not relevant_results:
        return {'tie_frequency_27': 0, 'time_since_last_tie': -1, 'tie_patterns': {}}
    tie_count_27 = relevant_results.count('tie')
    tie_frequency_27 = (tie_count_27 / len(relevant_results)) * 100 if len(relevant_results) > 0 else 0
    time_since_last_tie = -1
    for i, result in enumerate(results):  
        if result == 'tie': time_since_last_tie = i; break
    tie_patterns_found = collections.defaultdict(int)
    for i in range(len(relevant_results) - 1):
        color1 = get_color(relevant_results[i]); color2 = get_color(relevant_results[i+1])
        if color2 == 'yellow' and color1 != 'yellow': tie_patterns_found[f"Quebra para Empate ({color1.capitalize()}{get_color_emoji(color1)} para Empate{get_color_emoji('yellow')})"] += 1
        if i < len(relevant_results) - 2:
            color3 = get_color(relevant_results[i+2])
            if color3 == 'yellow':
                if color1 == 'blue' and color2 == 'red': tie_patterns_found["Jogador-Banca-Empate (ðŸ”µðŸ”´ðŸŸ¡)"] += 1 # AdaptaÃ§Ã£o
                elif color1 == 'red' and color2 == 'blue': tie_patterns_found["Banca-Jogador-Empate (ðŸ”´ðŸ”µðŸŸ¡)"] += 1 # AdaptaÃ§Ã£o
    return {
        'tie_frequency_27': round(tie_frequency_27, 2), 'time_since_last_tie': time_since_last_tie,
        'tie_patterns': dict(tie_patterns_found)
    }

# --- FunÃ§Ã£o de SugestÃ£o com "IA" Simulada Adaptada (Jogador/Banca) ---
def generate_advanced_suggestion(results, surf_analysis, color_analysis, break_probability, break_patterns, tie_specifics, pattern_performance):
    """Gera uma sugestÃ£o de aposta baseada em mÃºltiplas anÃ¡lises, com ajuste de confianÃ§a por performance de padrÃ£o."""
    if not results or len(results) < 5:  
        return {'suggestion': 'Aguardando mais resultados para anÃ¡lise detalhada.', 'confidence': 0, 'reason': '', 'guarantee_pattern': 'N/A'}

    last_result_color = color_analysis['current_color']
    current_streak = color_analysis['streak']
    
    suggestion = "Manter observaÃ§Ã£o"
    confidence = 50
    reason = "AnÃ¡lise preliminar."
    guarantee_pattern = "N/A"

    def adjust_confidence_by_performance(base_confidence, pattern_name):
        if pattern_name in pattern_performance:
            performance = pattern_performance[pattern_name]
            reliability = (performance['successes'] + 1) / (performance['successes'] + performance['failures'] + 2)
            adjusted_confidence = base_confidence * reliability * 1.2
            return min(95, max(20, int(adjusted_confidence)))
        return base_confidence

    # 1. SugestÃ£o baseada em SequÃªncia Longa e MÃ¡ximo HistÃ³rico de Surf
    if last_result_color == 'blue' and current_streak >= surf_analysis['max_player_sequence'] and surf_analysis['max_player_sequence'] > 0 and current_streak >= 3: # Adaptado para 'blue'/'player'
        pattern_name = f"Surf Max Quebra: {last_result_color.capitalize()}"
        confidence = adjust_confidence_by_performance(95, pattern_name)
        suggestion = f"APOSTA FORTE em **BANCA** {get_color_emoji('red')}" # Sugere Banca
        reason = f"SequÃªncia atual de Jogador ({current_streak}x) atingiu ou superou o mÃ¡ximo histÃ³rico de surf. Grande chance de quebra."
        guarantee_pattern = pattern_name
        return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
    elif last_result_color == 'red' and current_streak >= surf_analysis['max_banker_sequence'] and surf_analysis['max_banker_sequence'] > 0 and current_streak >= 3: # Adaptado para 'red'/'banker'
        pattern_name = f"Surf Max Quebra: {last_result_color.capitalize()}"
        confidence = adjust_confidence_by_performance(95, pattern_name)
        suggestion = f"APOSTA FORTE em **JOGADOR** {get_color_emoji('blue')}" # Sugere Jogador
        reason = f"SequÃªncia atual de Banca ({current_streak}x) atingiu ou superou o mÃ¡ximo histÃ³rico de surf. Grande chance de quebra."
        guarantee_pattern = pattern_name
        return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
    elif last_result_color == 'yellow' and current_streak >= surf_analysis['max_tie_sequence'] and surf_analysis['max_tie_sequence'] > 0 and current_streak >= 2:
        pattern_name = f"Surf Max Quebra: {last_result_color.capitalize()}"
        confidence = adjust_confidence_by_performance(90, pattern_name)
        suggestion = f"APOSTA FORTE em **JOGADOR** {get_color_emoji('blue')} ou **BANCA** {get_color_emoji('red')}" # Sugere Jogador ou Banca
        reason = f"SequÃªncia atual de Empate ({current_streak}x) atingiu ou superou o mÃ¡ximo histÃ³rico de surf. Grande chance de retorno Ã s cores principais."
        guarantee_pattern = pattern_name
        return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}

    # 2. SugestÃ£o baseada em padrÃµes recorrentes de quebra (2x1, 3x1)
    for pattern, count in break_patterns.items():
        if count >= 3:  
            if "2x1 (Blue ðŸ”µ Red ðŸ”´)" in pattern and last_result_color == 'blue' and current_streak == 2: # AdaptaÃ§Ã£o de cores
                confidence = adjust_confidence_by_performance(88, pattern)
                suggestion = f"Apostar em **BANCA** {get_color_emoji('red')}"
                reason = f"PadrÃ£o 2x1 (ðŸ”µðŸ”µðŸ”´) altamente recorrente ({count}x). Espera-se a quebra para Banca."
                guarantee_pattern = pattern
                return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
            elif "2x1 (Red ðŸ”´ Blue ðŸ”µ)" in pattern and last_result_color == 'red' and current_streak == 2: # AdaptaÃ§Ã£o de cores
                confidence = adjust_confidence_by_performance(88, pattern)
                suggestion = f"Apostar em **JOGADOR** {get_color_emoji('blue')}"
                reason = f"PadrÃ£o 2x1 (ðŸ”´ðŸ”´ðŸ”µ) altamente recorrente ({count}x). Espera-se a quebra para Jogador."
                guarantee_pattern = pattern
                return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
            
            elif "3x1 (Blue ðŸ”µ Red ðŸ”´)" in pattern and last_result_color == 'blue' and current_streak == 3: # AdaptaÃ§Ã£o de cores
                confidence = adjust_confidence_by_performance(92, pattern)
                suggestion = f"Apostar em **BANCA** {get_color_emoji('red')}"
                reason = f"PadrÃ£o 3x1 (ðŸ”µðŸ”µðŸ”µðŸ”´) altamente recorrente ({count}x). Espera-se a quebra para Banca."
                guarantee_pattern = pattern
                return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
            elif "3x1 (Red ðŸ”´ Blue ðŸ”µ)" in pattern and last_result_color == 'red' and current_streak == 3: # AdaptaÃ§Ã£o de cores
                confidence = adjust_confidence_by_performance(92, pattern)
                suggestion = f"Apostar em **JOGADOR** {get_color_emoji('blue')}"
                reason = f"PadrÃ£o 3x1 (ðŸ”´ðŸ”´ðŸ”´ðŸ”µ) altamente recorrente ({count}x). Espera-se a quebra para Jogador."
                guarantee_pattern = pattern
                return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}

    # 3. SugestÃ£o de Empate (maior assertividade)
    if tie_specifics['time_since_last_tie'] >= 7 and tie_specifics['tie_frequency_27'] < 12:  
        pattern_name = "Empate Atrasado/Baixa FrequÃªncia"
        confidence = adjust_confidence_by_performance(78, pattern_name)
        suggestion = f"Considerar **EMPATE** {get_color_emoji('yellow')}"
        reason = f"Empate nÃ£o ocorre hÃ¡ {tie_specifics['time_since_last_tie']} rodadas e frequÃªncia baixa ({tie_specifics['tie_frequency_27']}% nos Ãºltimos 27)."
        guarantee_pattern = pattern_name
        
        # ReforÃ§o com padrÃµes de empate
        if "Jogador-Banca-Empate (ðŸ”µðŸ”´ðŸŸ¡)" in tie_specifics['tie_patterns'] and len(results) >= 2 and results[0] == 'banker' and results[1] == 'player': # AdaptaÃ§Ã£o
            confidence = adjust_confidence_by_performance(confidence + 10, pattern_name + " + PadrÃ£o ðŸ”µðŸ”´ðŸŸ¡")
            suggestion += f" - ReforÃ§ado por padrÃ£o ðŸ”µðŸ”´ðŸŸ¡."
            guarantee_pattern += " + PadrÃ£o ðŸ”µðŸ”´ðŸŸ¡"
        elif "Banca-Jogador-Empate (ðŸ”´ðŸ”µðŸŸ¡)" in tie_specifics['tie_patterns'] and len(results) >= 2 and results[0] == 'player' and results[1] == 'banker': # AdaptaÃ§Ã£o
            confidence = adjust_confidence_by_performance(confidence + 10, pattern_name + " + PadrÃ£o ðŸ”´ðŸ”µðŸŸ¡")
            suggestion += f" - ReforÃ§ado por padrÃ£o ðŸ”´ðŸ”µðŸŸ¡."
            guarantee_pattern += " + PadrÃ£o ðŸ”´ðŸ”µðŸŸ¡"
        
        return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}
    
    # Se os Ãºltimos 2 foram alternados (B-R ou R-B) e nÃ£o houve empate em X rodadas
    if len(results) >= 2 and ( (get_color(results[0]) == 'blue' and get_color(results[1]) == 'red') or \
                               (get_color(results[0]) == 'red' and get_color(results[1]) == 'blue') ):
        if tie_specifics['time_since_last_tie'] >= 3:
            pattern_name = "AlternÃ¢ncia para Empate"
            confidence = adjust_confidence_by_performance(75, pattern_name)
            suggestion = f"Considerar **EMPATE** {get_color_emoji('yellow')}"
            reason = "Resultados alternados (ðŸ”µðŸ”´ ou ðŸ”´ðŸ”µ) podem preceder um empate. Empate atrasado."
            guarantee_pattern = pattern_name
            return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}

    # 4. Outras SugestÃµes (se as acima nÃ£o se aplicarem com alta confianÃ§a)
    if break_probability['break_chance'] > 65 and current_streak < 3:  
        if len(results) >= 2:
            prev_color = get_color(results[1])
            pattern_name = "Alta Probabilidade de Quebra Geral"
            confidence = adjust_confidence_by_performance(70, pattern_name)
            if prev_color == 'blue':
                suggestion = f"Apostar em **BANCA** {get_color_emoji('red')}"
                reason = f"Alta chance de quebra ({break_probability['break_chance']}%). Prever quebra de sequÃªncia de {prev_color.capitalize()}."
            elif prev_color == 'red':
                suggestion = f"Apostar em **JOGADOR** {get_color_emoji('blue')}"
                reason = f"Alta chance de quebra ({break_probability['break_chance']}%). Prever quebra de sequÃªncia de {prev_color.capitalize()}."
            return {'suggestion': suggestion, 'confidence': confidence, 'reason': reason, 'guarantee_pattern': guarantee_pattern}

    suggestion = "Manter observaÃ§Ã£o."
    confidence = 50
    reason = "Nenhum padrÃ£o de 'garantÃ­a' forte detectado nos Ãºltimos 27 resultados para uma aposta segura no momento."
    guarantee_pattern = "Nenhum PadrÃ£o Forte"

    return {
        'suggestion': suggestion,  
        'confidence': round(confidence),  
        'reason': reason,
        'guarantee_pattern': guarantee_pattern
    }

def update_analysis(results, pattern_performance):
    """Coordena todas as anÃ¡lises e retorna os resultados consolidados, focando nos Ãºltimos N."""
    relevant_results_for_analysis = results[:NUM_RECENT_RESULTS_FOR_ANALYSIS]

    if not relevant_results_for_analysis:
        return {
            'stats': {'player': 0, 'banker': 0, 'tie': 0, 'total': 0}, # Adaptado para 'player', 'banker', 'tie'
            'surf_analysis': analyze_surf([]),
            'color_analysis': analyze_colors([]),
            'break_patterns': find_break_patterns([]),
            'break_probability': analyze_break_probability([]),
            'tie_specifics': analyze_tie_specifics([]),
            'suggestion': {'suggestion': 'Aguardando resultados para anÃ¡lise.', 'confidence': 0, 'reason': '', 'guarantee_pattern': 'N/A'}
        }

    stats = {'player': relevant_results_for_analysis.count('player'),  
             'banker': relevant_results_for_analysis.count('banker'),  
             'tie': relevant_results_for_analysis.count('tie'),  
             'total': len(relevant_results_for_analysis)}
    
    surf_analysis = analyze_surf(results)  
    color_analysis = analyze_colors(results)
    break_patterns = find_break_patterns(results)
    break_probability = analyze_break_probability(results)
    tie_specifics = analyze_tie_specifics(results)

    suggestion_data = generate_advanced_suggestion(results, surf_analysis, color_analysis, break_probability, break_patterns, tie_specifics, pattern_performance)
    
    return {
        'stats': stats,
        'surf_analysis': surf_analysis,
        'color_analysis': color_analysis,
        'break_patterns': break_patterns,
        'break_probability': break_probability,
        'tie_specifics': tie_specifics,
        'suggestion': suggestion_data
    }

# --- FunÃ§Ã£o para Renderizar o HistÃ³rico (Roadmap) ---
def render_roadmap_history(results_list_latest_first, max_cols=30, max_rows_per_col=6):
    """
    Renderiza o histÃ³rico em formato de roadmap (torre e linha) usando emojis e st.columns.
    max_cols limita o nÃºmero de colunas exibidas.
    max_rows_per_col limita a altura de cada coluna para evitar rolagem excessiva e manter a visualizaÃ§Ã£o padrÃ£o do roadmap.
    """
    if not results_list_latest_first:
        st.write("Nenhum resultado para exibir o roadmap.")
        return

    results_oldest_first = results_list_latest_first[::-1] # Inverter para analisar do mais antigo para o mais novo

    roadmap_columns_data = []
    current_column = []

    for i, result in enumerate(results_oldest_first):
        emoji = get_color_emoji(get_color(result))

        if not current_column:
            current_column.append(emoji)
        else:
            last_result_in_current_col_color = get_color(results_oldest_first[i-1])
            current_result_color = get_color(result)

            if current_result_color == last_result_in_current_col_color:
                current_column.append(emoji)
            else:
                roadmap_columns_data.append(current_column)
                current_column = [emoji]
    
    if current_column: # Adicionar a Ãºltima coluna se houver
        roadmap_columns_data.append(current_column)

    # Limitar o nÃºmero de colunas a serem exibidas
    roadmap_columns_data = roadmap_columns_data[-max_cols:]

    # Encontrar a altura mÃ¡xima para alinhar as linhas
    max_height = max(len(col) for col in roadmap_columns_data) if roadmap_columns_data else 0

    # Ajustar a altura mÃ¡xima para a altura padrÃ£o de roadmap (geralmente 6)
    display_height = min(max_height, max_rows_per_col)

    # Criar uma lista de colunas Streamlit que se estenderÃ¡ por toda a largura
    # Cada coluna do roadmap_columns_data serÃ¡ uma coluna Streamlit
    cols_streamlit = st.columns(len(roadmap_columns_data))

    # Preencher as colunas do Streamlit linha por linha (de baixo para cima para simular o roadmap)
    for r_idx in range(display_height): # Iterar pelas linhas do roadmap (de 0 atÃ© display_height-1)
        for c_idx, col_data in enumerate(roadmap_columns_data): # Iterar por cada coluna de dados do roadmap
            
            emoji_to_display = " "
            if r_idx >= (display_height - len(col_data)):
                # Calcula o Ã­ndice real na lista col_data
                actual_idx_in_col_data = r_idx - (display_height - len(col_data))
                emoji_to_display = col_data[actual_idx_in_col_data]
            
            with cols_streamlit[c_idx]:
                st.markdown(emoji_to_display)
            else: # Add empty column if no data
                with cols_streamlit[c_idx]:
                    st.markdown(" ") # EspaÃ§o vazio para alinhar as colunas

# --- Streamlit UI ---

st.set_page_config(layout="wide", page_title="Bac Bo Pro Analyzer (Roadmap e IA Sim.)")

st.title("ðŸŽ² Bac Bo Pro Analyzer (Roadmap e IA Sim. Adaptativa)")
st.write("Sistema AvanÃ§ado de AnÃ¡lise e PrediÃ§Ã£o com AdaptaÃ§Ã£o de PadrÃµes para Bac Bo")

# --- Gerenciamento de Estado ---
if 'results' not in st.session_state:
    st.session_state.results = []
if 'last_suggested_bet_info' not in st.session_state:  
    st.session_state.last_suggested_bet_info = None
if 'guarantee_failed_streak' not in st.session_state:  
    st.session_state.guarantee_failed_streak = 0
if 'pattern_performance' not in st.session_state:
    st.session_state.pattern_performance = {}  

if 'analysis_data' not in st.session_state:
    st.session_state.analysis_data = update_analysis(st.session_state.results, st.session_state.pattern_performance)


# --- FunÃ§Ã£o para Adicionar Resultado ---
def add_result(result):
    if st.session_state.last_suggested_bet_info:
        last_suggestion = st.session_state.last_suggested_bet_info
        suggested_outcome = None  

        if "JOGADOR" in last_suggestion['suggestion']: # Adaptado
            suggested_outcome = 'player'
        elif "BANCA" in last_suggestion['suggestion']: # Adaptado
            suggested_outcome = 'banker'
        elif "EMPATE" in last_suggestion['suggestion']:
            suggested_outcome = 'tie'

        if suggested_outcome and last_suggestion['confidence'] >= 70 and last_suggestion['guarantee_pattern'] != 'Nenhum PadrÃ£o Forte':
            actual_color = get_color(result)
            suggested_color = get_color(suggested_outcome)
            
            pattern_name = last_suggestion['guarantee_pattern']
            if pattern_name not in st.session_state.pattern_performance:
                st.session_state.pattern_performance[pattern_name] = {'successes': 0, 'failures': 0}

            if actual_color == suggested_color:
                st.session_state.pattern_performance[pattern_name]['successes'] += 1
                st.session_state.guarantee_failed_streak = 0  
            else:
                st.session_state.pattern_performance[pattern_name]['failures'] += 1
                st.session_state.guarantee_failed_streak += 1  
                st.warning(f"ðŸš¨ **ALERTA: A GARANTIA DO PADRÃƒO '{pattern_name}' FALHOU!**")
                
        else:  
            st.session_state.guarantee_failed_streak = 0

    st.session_state.results.insert(0, result)  
    st.session_state.results = st.session_state.results[:MAX_HISTORY_TO_STORE]  
    
    st.session_state.analysis_data = update_analysis(st.session_state.results, st.session_state.pattern_performance)
    
    st.session_state.last_suggested_bet_info = st.session_state.analysis_data['suggestion']
    
# --- FunÃ§Ã£o para Limpar HistÃ³rico ---
def clear_history():
    st.session_state.results = []
    st.session_state.analysis_data = update_analysis([], {})  
    st.session_state.last_suggested_bet_info = None
    st.session_state.guarantee_failed_streak = 0
    st.session_state.pattern_performance = {}  
    st.experimental_rerun()  

# --- Layout ---
st.header("Registrar Resultado")
col1, col2, col3 = st.columns(3)

with col1:
    if st.button("JOGADOR ðŸ”µ", use_container_width=True): # BotÃ£o Jogador (Azul)
        add_result('player')
with col2:
    if st.button("BANCA ðŸ”´", use_container_width=True): # BotÃ£o Banca (Vermelho)
        add_result('banker')
with col3:
    if st.button("EMPATE ðŸŸ¡", use_container_width=True): # BotÃ£o Empate (Amarelo)
        add_result('tie')

st.markdown("---")

# --- Exibir Alerta de Garantia ---
if st.session_state.guarantee_failed_streak > 0:
    st.error(f"ðŸš¨ **ALERTA DE FAIXA DE FALHA!** A garantia falhou **{st.session_state.guarantee_failed_streak}** vez(es) consecutiva(s). Considere cautela ou reanalisar. A IA estÃ¡ ajustando a confianÃ§a dos padrÃµes.")

st.header("AnÃ¡lise IA e SugestÃ£o")
if st.session_state.results:
    suggestion = st.session_state.analysis_data['suggestion']
    
    st.info(f"**SugestÃ£o:** {suggestion['suggestion']}")
    st.metric(label="ConfianÃ§a", value=f"{suggestion['confidence']}%")
    st.write(f"**Motivo:** {suggestion['reason']}")
    st.write(f"**PadrÃ£o de Garantia da SugestÃ£o:** `{suggestion['guarantee_pattern']}`")
else:
    st.info("Aguardando resultados para gerar anÃ¡lises e sugestÃµes.")

st.markdown("---")

# --- HistÃ³rico dos Ãšltimos Resultados (Roadmap) ---
st.header("ðŸ“œ HistÃ³rico de Resultados (Roadmap Bac Bo)")
# Envolver a renderizaÃ§Ã£o do roadmap em uma div com estilo para centralizar, se necessÃ¡rio
st.markdown("<div style='display: flex; justify-content: center;'>", unsafe_allow_html=True)
render_roadmap_history(st.session_state.results)  
st.markdown("</div>", unsafe_allow_html=True)

st.markdown("---")

# --- EstatÃ­sticas e PadrÃµes (Ãšltimos 27 Resultados) ---
st.header(f"EstatÃ­sticas e PadrÃµes (Ãšltimos {NUM_RECENT_RESULTS_FOR_ANALYSIS} Resultados)")

stats_col, color_col = st.columns(2)

with stats_col:
    st.subheader("EstatÃ­sticas Gerais")
    stats = st.session_state.analysis_data['stats']
    st.write(f"**Jogador {get_color_emoji('blue')}:** {stats['player']} vezes")
    st.write(f"**Banca {get_color_emoji('red')}:** {stats['banker']} vezes")
    st.write(f"**Empate {get_color_emoji('yellow')}:** {stats['tie']} vezes")
    st.write(f"**Total de Resultados Analisados:** {stats['total']}")

with color_col:
    st.subheader("AnÃ¡lise de Cores")
    colors = st.session_state.analysis_data['color_analysis']
    st.write(f"**Azul (Jogador):** {colors['blue']}x")
    st.write(f"**Vermelho (Banca):** {colors['red']}x")
    st.write(f"**Amarelo (Empate):** {colors['yellow']}x")
    st.write(f"**SequÃªncia Atual:** {colors['streak']}x {colors['current_color'].capitalize()} {get_color_emoji(colors['current_color'])}")
    st.markdown(f"**PadrÃ£o (Ãšltimos {NUM_RECENT_RESULTS_FOR_ANALYSIS}):** `{colors['color_pattern_27']}`")

st.markdown("---")

# --- AnÃ¡lise de Quebra, Surf e Empate ---
col_break, col_surf, col_tie_analysis = st.columns(3)

with col_break:
    st.subheader("AnÃ¡lise de Quebra")
    bp = st.session_state.analysis_data['break_probability']
    st.write(f"**Chance de Quebra:** {bp['break_chance']}%")
    st.write(f"**Ãšltimo Tipo de Quebra:** {bp['last_break_type'] if bp['last_break_type'] else 'N/A'}")
    
    st.subheader("PadrÃµes de Quebra e EspecÃ­ficos")
    patterns = st.session_state.analysis_data['break_patterns'] # Completed this line
    if patterns:
        for pattern, count in patterns.items():
            st.write(f"- {pattern}: {count}x")
    else:
        st.write("Nenhum padrÃ£o de quebra significativo detectado.")

with col_surf:
    st.subheader("AnÃ¡lise de Surf")
    surf = st.session_state.analysis_data['surf_analysis']
    st.write(f"**SequÃªncia Atual (Jogador {get_color_emoji('blue')}):** {surf['player_sequence']}x")
    st.write(f"**MÃ¡x. SequÃªncia HistÃ³rica (Jogador {get_color_emoji('blue')}):** {surf['max_player_sequence']}x")
    st.write(f"**SequÃªncia Atual (Banca {get_color_emoji('red')}):** {surf['banker_sequence']}x")
    st.write(f"**MÃ¡x. SequÃªncia HistÃ³rica (Banca {get_color_emoji('red')}):** {surf['max_banker_sequence']}x")
    st.write(f"**SequÃªncia Atual (Empate {get_color_emoji('yellow')}):** {surf['tie_sequence']}x")
    st.write(f"**MÃ¡x. SequÃªncia HistÃ³rica (Empate {get_color_emoji('yellow')}):** {surf['max_tie_sequence']}x")

with col_tie_analysis:
    st.subheader("AnÃ¡lise de Empate")
    tie_spec = st.session_state.analysis_data['tie_specifics']
    st.write(f"**FrequÃªncia de Empate (Ãºltimos {NUM_RECENT_RESULTS_FOR_ANALYSIS}):** {tie_spec['tie_frequency_27']}%")
    st.write(f"**Tempo desde o Ãšltimo Empate:** {tie_spec['time_since_last_tie']} rodadas")
    st.write("**PadrÃµes de Empate Detectados:**")
    if tie_spec['tie_patterns']:
        for pattern, count in tie_spec['tie_patterns'].items():
            st.write(f"- {pattern}: {count}x")
    else:
        st.write("Nenhum padrÃ£o de empate especÃ­fico detectado.")

st.markdown("---")

# --- Performance dos PadrÃµes (IA) ---
st.header("ðŸ“ˆ Performance dos PadrÃµes (IA Adaptativa)")
if st.session_state.pattern_performance:
    performance_df = pd.DataFrame.from_dict(st.session_state.pattern_performance, orient='index')
    performance_df.index.name = 'PadrÃ£o'
    performance_df['Total'] = performance_df['successes'] + performance_df['failures']
    performance_df['Acerto (%)'] = (performance_df['successes'] / performance_df['Total'] * 100).round(2)
    st.dataframe(performance_df.sort_values(by='Total', ascending=False))
else:
    st.info("A performance dos padrÃµes serÃ¡ rastreada apÃ³s sugestÃµes com garantia serem feitas e resultados registrados.")

st.markdown("---")

# --- BotÃ£o para Limpar HistÃ³rico ---
st.button("Limpar Todo o HistÃ³rico", on_click=clear_history, help="Apaga todos os resultados e dados de anÃ¡lise.", type="secondary")

st.caption("Desenvolvido para anÃ¡lise de padrÃµes no Bac Bo. Use com cautela e responsabilidade.")
